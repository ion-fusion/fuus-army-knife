// Copyright Ion Fusion contributors. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
#[macro_use]
extern crate derive_new;
#[macro_use]
extern crate serde_derive;

#[macro_use]
mod error_macro;

mod ast;
mod check;
mod config;
mod diff_util;
mod error;
mod file;
mod format;
mod index;
mod lexer;
mod parser;
mod span;
mod string_util;

use crate::config::{FusionConfig, load_config, write_default_config};
use crate::error::Error;
use crate::file::{FusionFile, FusionFileContent};
use clap::{Parser, Subcommand, ValueHint};
use std::env;
use std::fs::{self, File};
use std::io::Write;

fn main() {
    let args = Args::parse();

    match args.command {
        Command::CreateConfig => {
            subcommand_create_config();
        }
        Command::Configured(configured_command) => {
            let fusion_config = load_config(args.config.as_deref(), false).unwrap_or_else(|error| bail!("{}", error));
            match configured_command {
                ConfiguredCommand::CheckCorrectnessWatch => {
                    subcommand_check_correctness_watch(&fusion_config);
                }
                ConfiguredCommand::Checkstyle { file } => {
                    subcommand_checkstyle(&fusion_config, &file);
                }
                ConfiguredCommand::CheckstyleAll => {
                    subcommand_checkstyle_all(&fusion_config);
                }
                ConfiguredCommand::DebugParser { file } => {
                    subcommand_debug_parser(&fusion_config, &file);
                }
                ConfiguredCommand::DebugIndex => {
                    subcommand_debug_index(&fusion_config).unwrap_or_else(|err| bail!("Failed: {}", err));
                }
                ConfiguredCommand::Format { file } => {
                    subcommand_format(&fusion_config, &file);
                }
                ConfiguredCommand::FormatAll => {
                    subcommand_format_all(&fusion_config);
                }
                ConfiguredCommand::FormatServer => {
                    subcommand_format_server(&fusion_config);
                }
            }
        }
    }
}

#[derive(Parser)]
#[command(version, about = "A Fusion auto-formatter")]
struct Args {
    /// Specifies the config file to use
    #[arg(long, short, value_name = "FILE", value_hint = ValueHint::FilePath)]
    config: Option<String>,

    #[command(subcommand)]
    command: Command,
}

#[derive(Subcommand)]
enum Command {
    /// creates a config file for Fuus Army Knife in the current directory
    CreateConfig,

    #[command(flatten)]
    Configured(ConfiguredCommand),
}

#[derive(Subcommand)]
enum ConfiguredCommand {
    /// outputs parsed abstract syntax tree of a Fusion file
    DebugParser {
        #[arg(value_name = "FILE", value_hint = ValueHint::FilePath)]
        file: String,
    },

    /// outputs binding index generated by examining all the Fusion files in a package
    DebugIndex,

    /// formats a single file
    Format {
        #[arg(value_name = "FILE", value_hint = ValueHint::FilePath)]
        file: String,
    },

    /// recursively formats all Fusion files in the current directory
    FormatAll,

    /// watches for changes to current package and checks for syntax errors
    CheckCorrectnessWatch,

    /// recursively checks adherence to format on all Fusion files in the current directory
    CheckstyleAll,

    /// starts a format server which listens on stdin and outputs formatted code to stdout
    FormatServer,

    /// checks the style of a single file
    Checkstyle {
        #[arg(value_hint = ValueHint::FilePath)]
        file: String,
    },
}

fn subcommand_debug_parser(fusion_config: &FusionConfig, path: &str) {
    let file_contents = FusionFileContent::load(path).unwrap_or_else(|err| bail!("{}", err));
    let file = file_contents
        .parse(fusion_config)
        .unwrap_or_else(|err| bail!("{}", err));
    println!("{}", file.debug_ast());
}

fn subcommand_debug_index(fusion_config: &FusionConfig) -> Result<(), Error> {
    let current_package_path =
        env::current_dir().map_err(|err| err_generic!("failed to determine current working directory: {}", err))?;
    let fusion_index = index::load_index(fusion_config, &current_package_path)?;
    println!("Index:\n{:#?}", fusion_index.borrow());
    Ok(())
}

fn subcommand_create_config() {
    write_default_config().unwrap_or_else(|err| bail!("Failed to write default config: {}", err));
}

fn format_file_in_place(fusion_config: &FusionConfig, fusion_file: &FusionFile) {
    let formatted = format::format(fusion_config, &fusion_file.ast);

    // Write formatted to a temp file
    let temp_file_path = fusion_file.file_name.with_extension("tmp-fuusak");
    let mut temp_file =
        File::create(&temp_file_path).unwrap_or_else(|err| bail!("Failed to create temp file: {}", err));
    write!(temp_file, "{}", formatted).unwrap_or_else(|err| bail!("Failed to write to temp file: {}", err));

    // Replace original file with temp file via rename
    fs::rename(&temp_file_path, &fusion_file.file_name).unwrap_or_else(|err| {
        bail!(
            "Failed to overwrite {:?} with formatted output: {}",
            fusion_file.file_name,
            err
        )
    });
}

fn checkstyle(fusion_config: &FusionConfig, file: &FusionFile) -> bool {
    println!("Checking {:?}...", file.file_name);
    let formatted = format::format(fusion_config, &file.ast);
    let expected = formatted.trim_end();
    let actual = file.contents.trim_end();
    if expected != actual {
        println!(
            "File {:?} doesn't adhere to correct style. See diff to correct below:",
            file.file_name
        );
        println!("{}", diff_util::human_diff_lines(actual, expected));
        false
    } else {
        true
    }
}

fn subcommand_format(fusion_config: &FusionConfig, path: &str) {
    let file_content = FusionFileContent::load(path).unwrap_or_else(|err| bail!("{}", err));
    let file = file_content.parse(fusion_config).unwrap_or_else(|err| bail!("{}", err));
    format_file_in_place(fusion_config, &file);
}

fn subcommand_format_all(fusion_config: &FusionConfig) {
    let fusion_files =
        FusionFile::recursively_load_directory(fusion_config, "./").unwrap_or_else(|err| bail!("{}", err));
    for file in &fusion_files {
        println!("Formatting {:?}...", file.file_name);
        format_file_in_place(fusion_config, file);
    }
}

fn subcommand_check_correctness_watch(fusion_config: &FusionConfig) {
    while check::check_correctness_watch(fusion_config).unwrap_or_else(|err| bail!("Failed: {}", err)) {}
}

fn subcommand_checkstyle_all(fusion_config: &FusionConfig) {
    let fusion_files =
        FusionFile::recursively_load_directory(fusion_config, "./").unwrap_or_else(|err| bail!("{}", err));
    let mut passed = true;
    for file in &fusion_files {
        if !checkstyle(fusion_config, file) {
            passed = false;
        }
    }
    if !passed {
        bail!("Checkstyle failed.")
    } else {
        println!("All files adhere to correct style.")
    }
}

fn subcommand_checkstyle(fusion_config: &FusionConfig, path: &str) {
    let file = FusionFile::load(fusion_config, path).unwrap_or_else(|err| bail!("{}", err));
    if !checkstyle(fusion_config, &file) {
        bail!("Checkstyle failed.")
    } else {
        println!("{} adheres to correct style.", path)
    }
}

fn subcommand_format_server(fusion_config: &FusionConfig) {
    let file_content = FusionFileContent::load_stdin().unwrap_or_else(|err| bail!("{}", err));
    let file = file_content.parse(fusion_config).unwrap_or_else(|err| bail!("{}", err));
    let formatted = format::format(fusion_config, &file.ast);
    print!("{}", formatted)
}
