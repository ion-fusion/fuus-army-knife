// Copyright Ion Fusion contributors. All Rights Reserved.
#![warn(rust_2018_idioms)]

#[macro_use]
extern crate derive_new;
#[macro_use]
extern crate serde_derive;

#[macro_use]
mod error_macro;

mod ast;
mod config;
mod diff_util;
mod error;
mod file;
mod format;
mod index;
mod lexer;
mod parser;
mod span;
mod string_util;

use crate::config::{load_config, write_default_config, FusionConfig};
use crate::error::Error;
use crate::file::{FusionFile, FusionFileContent};
use clap::{crate_version, App, Arg, SubCommand};
use std::collections::HashSet;
use std::io::Write;
use std::process;
use tempfile::NamedTempFile;

fn main() {
    let mut clap_app = configure_clap_app();
    let app_matches = clap_app.clone().get_matches();

    // Run create-config sub-command before trying to load config
    if app_matches.subcommand_matches("create-config").is_some() {
        subcommand_create_config();
    }

    let config_file_name = app_matches
        .value_of("config")
        .unwrap_or_else(|| "fuusak.toml");
    let fusion_config = load_config(config_file_name).unwrap_or_else(|error| bail!("{}", error));

    if let Some(matches) = app_matches.subcommand_matches("debug-parser") {
        let path = matches.value_of("FILE").unwrap();
        subcommand_debug_parser(&fusion_config, path);
    } else if let Some(matches) = app_matches.subcommand_matches("debug-index") {
        let path = matches.value_of("FILE").unwrap();
        subcommand_debug_index(&fusion_config, path).unwrap_or_else(|err| bail!("Failed: {}", err));
    } else if let Some(matches) = app_matches.subcommand_matches("format") {
        let path = matches.value_of("FILE").unwrap();
        subcommand_format(&fusion_config, path);
    } else if let Some(_) = app_matches.subcommand_matches("format-all") {
        subcommand_format_all(&fusion_config);
    } else if let Some(_) = app_matches.subcommand_matches("checkstyle-all") {
        subcommand_checkstyle_all(&fusion_config);
    } else {
        drop(clap_app.print_help());
        println!("\n")
    }
}

fn configure_clap_app<'a, 'b>() -> App<'a, 'b> {
    App::new("Fuus Army Knife (fuusak)")
        .version(crate_version!())
        .about("A Fusion auto-formatter")
        .arg(
            Arg::with_name("config")
                .short("c")
                .long("config")
                .value_name("FILE")
                .takes_value(true)
                .help("Specifies the config file to use"),
        )
        .subcommand(
            SubCommand::with_name("debug-parser")
                .about("outputs parsed abstract syntax tree of a Fusion file")
                .arg(Arg::with_name("FILE").required(true).index(1)),
        )
        .subcommand(
            SubCommand::with_name("debug-index")
                .about("outputs binding index generated by following references in a Fusion file")
                .arg(Arg::with_name("FILE").required(true).index(1)),
        )
        .subcommand(
            SubCommand::with_name("create-config")
                .about("creates a config file for Fuus Army Knife in the current directory"),
        )
        .subcommand(
            SubCommand::with_name("format")
                .about("formats a single file")
                .arg(Arg::with_name("FILE").required(true).index(1)),
        )
        .subcommand(
            SubCommand::with_name("format-all")
                .about("recursively formats all Fusion files in the current directory"),
        )
        .subcommand(SubCommand::with_name("checkstyle-all").about(
            "recursively checks adherence to format on all Fusion files in the current directory",
        ))
        .subcommand(SubCommand::with_name("help"))
}

fn subcommand_debug_parser(fusion_config: &FusionConfig, path: &str) {
    let file_contents = FusionFileContent::load(path).unwrap_or_else(|err| bail!("{}", err));
    let file = file_contents
        .parse(fusion_config)
        .unwrap_or_else(|err| bail!("{}", err));
    println!("{}", file.debug_ast());
}

fn subcommand_debug_index(fusion_config: &FusionConfig, path: &str) -> Result<(), Error> {
    use crate::index::*;

    let current_package_path = env::current_dir()
        .map_err(|err| err_generic!("failed to determine current working directory: {}", err))?;
    let mut paths = Vec::new();
    for path_config in &fusion_config.path_configs {
        for directory in &path_config.directories {
            let full_path = current_package_path.join(directory);
            if full_path.exists() {
                paths.push(full_path);
            }
        }
    }

    let module_repo = ModuleRepo::new(current_package_path, paths)?;
    let module_loader = ModuleLoader::new(fusion_config, module_repo.clone());

    module_loader.load_file(path)?;

    println!("Module repository:\n{:#?}", module_repo.borrow());
    Ok(())
}

fn subcommand_create_config() {
    write_default_config().unwrap_or_else(|err| bail!("Failed to write default config: {}", err));
    process::exit(0);
}

fn format_file_in_place(fusion_config: &FusionConfig, fusion_file: &FusionFile) {
    let formatted = format::format(fusion_config, &fusion_file.ast);

    // Write formatted to a temp file
    let mut temp_file: NamedTempFile =
        NamedTempFile::new().unwrap_or_else(|err| bail!("Failed to create temp file: {}", err));
    write!(temp_file, "{}", formatted)
        .unwrap_or_else(|err| bail!("Failed to write to temp file: {}", err));

    // Replace original file with temp file via rename
    temp_file
        .into_temp_path()
        .persist(&fusion_file.file_name)
        .unwrap_or_else(|err| {
            bail!(
                "Failed to overwrite {:?} with formatted output: {}",
                fusion_file.file_name,
                err
            )
        });
}

fn subcommand_format(fusion_config: &FusionConfig, path: &str) {
    let file_content = FusionFileContent::load(path).unwrap_or_else(|err| bail!("{}", err));
    let file = file_content
        .parse(fusion_config)
        .unwrap_or_else(|err| bail!("{}", err));
    format_file_in_place(fusion_config, &file);
}

fn subcommand_format_all(fusion_config: &FusionConfig) {
    let fusion_files = FusionFile::recursively_load_directory(fusion_config, "./")
        .unwrap_or_else(|err| bail!("{}", err));
    for file in &fusion_files {
        println!("Formatting {:?}...", file.file_name);
        format_file_in_place(fusion_config, file);
    }
}

fn subcommand_checkstyle_all(fusion_config: &FusionConfig) {
    let fusion_files = FusionFile::recursively_load_directory(fusion_config, "./")
        .unwrap_or_else(|err| bail!("{}", err));
    let mut passed = true;
    for file in &fusion_files {
        println!("Checking {:?}...", file.file_name);
        let formatted = format::format(fusion_config, &file.ast);
        let expected = formatted.trim_end();
        let actual = file.contents.trim_end();
        if expected != actual {
            println!(
                "File {:?} doesn't adhere to correct style. See diff to correct below:",
                file.file_name
            );
            println!("{}", diff_util::human_diff_lines(actual, expected));
            passed = false;
        }
    }
    if !passed {
        bail!("Checkstyle failed.")
    } else {
        println!("All files adhere to correct style.")
    }
}
