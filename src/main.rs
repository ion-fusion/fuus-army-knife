// Copyright Ion Fusion contributors. All Rights Reserved.
#![warn(rust_2018_idioms)]

#[macro_use]
extern crate derive_new;
#[macro_use]
extern crate serde_derive;

#[macro_use]
mod error_macro;

mod ast;
mod check;
mod config;
mod diff_util;
mod error;
mod file;
mod format;
mod index;
mod lexer;
mod parser;
mod span;
mod string_util;

use crate::config::{load_config, write_default_config, FusionConfig};
use crate::error::Error;
use crate::file::{FusionFile, FusionFileContent};
use clap::{crate_version, App, Arg, SubCommand};
use std::env;
use std::fs::{self, File};
use std::io::Write;
use std::process;

fn main() {
    let mut clap_app = configure_clap_app();
    let app_matches = clap_app.clone().get_matches();

    // Run create-config sub-command before trying to load config
    if app_matches.subcommand_matches("create-config").is_some() {
        subcommand_create_config();
    }

    let config_file_name = app_matches.value_of("config");

    if let Some(_) = app_matches.subcommand_matches("format-server") {
        let fusion_config =
            load_config(config_file_name, true).unwrap_or_else(|error| bail!("{}", error));
        subcommand_format_server(&fusion_config);
        return;
    }

    let fusion_config =
        load_config(config_file_name, false).unwrap_or_else(|error| bail!("{}", error));

    if let Some(matches) = app_matches.subcommand_matches("debug-parser") {
        let path = matches.value_of("FILE").unwrap();
        subcommand_debug_parser(&fusion_config, path);
    } else if let Some(_) = app_matches.subcommand_matches("debug-index") {
        subcommand_debug_index(&fusion_config).unwrap_or_else(|err| bail!("Failed: {}", err));
    } else if let Some(matches) = app_matches.subcommand_matches("format") {
        let path = matches.value_of("FILE").unwrap();
        subcommand_format(&fusion_config, path);
    } else if let Some(_) = app_matches.subcommand_matches("format-all") {
        subcommand_format_all(&fusion_config);
    } else if let Some(_) = app_matches.subcommand_matches("check-correctness-watch") {
        subcommand_check_correctness_watch(&fusion_config);
    } else if let Some(_) = app_matches.subcommand_matches("checkstyle-all") {
        subcommand_checkstyle_all(&fusion_config);
    } else if let Some(matches) = app_matches.subcommand_matches("checkstyle") {
        let path = matches.value_of("FILE").unwrap();
        subcommand_checkstyle(&fusion_config, path);
    } else {
        drop(clap_app.print_help());
        println!("\n")
    }
}

fn configure_clap_app<'a, 'b>() -> App<'a, 'b> {
    App::new("Fuus Army Knife (fuusak)")
        .version(crate_version!())
        .about("A Fusion auto-formatter")
        .arg(
            Arg::with_name("config")
                .short("c")
                .long("config")
                .value_name("FILE")
                .takes_value(true)
                .help("Specifies the config file to use"),
        )
        .subcommand(
            SubCommand::with_name("debug-parser")
                .about("outputs parsed abstract syntax tree of a Fusion file")
                .arg(Arg::with_name("FILE").required(true).index(1)),
        )
        .subcommand(
            SubCommand::with_name("debug-index")
                .about("outputs binding index generated by examining all the Fusion files in a package"),
        )
        .subcommand(
            SubCommand::with_name("create-config")
                .about("creates a config file for Fuus Army Knife in the current directory"),
        )
        .subcommand(
            SubCommand::with_name("format")
                .about("formats a single file")
                .arg(Arg::with_name("FILE").required(true).index(1)),
        )
        .subcommand(
            SubCommand::with_name("format-all").about("recursively formats all Fusion files in the current directory"),
        )
        .subcommand(
            SubCommand::with_name("check-correctness-watch")
                .about("watches for changes to current package and checks for syntax errors and unbound identifiers"),
        )
        .subcommand(
            SubCommand::with_name("checkstyle-all")
                .about("recursively checks adherence to format on all Fusion files in the current directory"),
        )
        .subcommand(
            SubCommand::with_name("format-server")
                .about("starts a format server which listens on stdin and outputs formatted code to stdout"),
        )
        .subcommand(
            SubCommand::with_name("checkstyle")
                .about("checks the style of a single file")
                .arg(Arg::with_name("FILE").required(true).index(1)),
        )
        .subcommand(SubCommand::with_name("help"))
}

fn subcommand_debug_parser(fusion_config: &FusionConfig, path: &str) {
    let file_contents = FusionFileContent::load(path).unwrap_or_else(|err| bail!("{}", err));
    let file = file_contents
        .parse(fusion_config)
        .unwrap_or_else(|err| bail!("{}", err));
    println!("{}", file.debug_ast());
}

fn subcommand_debug_index(fusion_config: &FusionConfig) -> Result<(), Error> {
    let current_package_path = env::current_dir()
        .map_err(|err| err_generic!("failed to determine current working directory: {}", err))?;
    let fusion_index = index::load_index(fusion_config, &current_package_path)?;
    println!("Index:\n{:#?}", fusion_index.borrow());
    Ok(())
}

fn subcommand_create_config() {
    write_default_config().unwrap_or_else(|err| bail!("Failed to write default config: {}", err));
    process::exit(0);
}

fn format_file_in_place(fusion_config: &FusionConfig, fusion_file: &FusionFile) {
    let formatted = format::format(fusion_config, &fusion_file.ast);

    // Write formatted to a temp file
    let temp_file_path = fusion_file.file_name.with_extension("tmp-fuusak");
    let mut temp_file = File::create(&temp_file_path)
        .unwrap_or_else(|err| bail!("Failed to create temp file: {}", err));
    write!(temp_file, "{}", formatted)
        .unwrap_or_else(|err| bail!("Failed to write to temp file: {}", err));

    // Replace original file with temp file via rename
    fs::rename(&temp_file_path, &fusion_file.file_name).unwrap_or_else(|err| {
        bail!(
            "Failed to overwrite {:?} with formatted output: {}",
            fusion_file.file_name,
            err
        )
    });
}

fn checkstyle(fusion_config: &FusionConfig, file: &FusionFile) -> bool {
    println!("Checking {:?}...", file.file_name);
    let formatted = format::format(fusion_config, &file.ast);
    let expected = formatted.trim_end();
    let actual = file.contents.trim_end();
    if expected != actual {
        println!(
            "File {:?} doesn't adhere to correct style. See diff to correct below:",
            file.file_name
        );
        println!("{}", diff_util::human_diff_lines(actual, expected));
        return false;
    }
    return true;
}

fn subcommand_format(fusion_config: &FusionConfig, path: &str) {
    let file_content = FusionFileContent::load(path).unwrap_or_else(|err| bail!("{}", err));
    let file = file_content
        .parse(fusion_config)
        .unwrap_or_else(|err| bail!("{}", err));
    format_file_in_place(fusion_config, &file);
}

fn subcommand_format_all(fusion_config: &FusionConfig) {
    let fusion_files = FusionFile::recursively_load_directory(fusion_config, "./")
        .unwrap_or_else(|err| bail!("{}", err));
    for file in &fusion_files {
        println!("Formatting {:?}...", file.file_name);
        format_file_in_place(fusion_config, file);
    }
}

fn subcommand_check_correctness_watch(fusion_config: &FusionConfig) {
    while check::check_correctness_watch(fusion_config)
        .unwrap_or_else(|err| bail!("Failed: {}", err))
    {}
}

fn subcommand_checkstyle_all(fusion_config: &FusionConfig) {
    let fusion_files = FusionFile::recursively_load_directory(fusion_config, "./")
        .unwrap_or_else(|err| bail!("{}", err));
    let mut passed = true;
    for file in &fusion_files {
        if !checkstyle(fusion_config, file) {
            passed = false;
        }
    }
    if !passed {
        bail!("Checkstyle failed.")
    } else {
        println!("All files adhere to correct style.")
    }
}

fn subcommand_checkstyle(fusion_config: &FusionConfig, path: &str) {
    let file = FusionFile::load(fusion_config, path).unwrap_or_else(|err| bail!("{}", err));
    if !checkstyle(fusion_config, &file) {
        bail!("Checkstyle failed.")
    } else {
        println!("{} adheres to correct style.", path)
    }
}

fn subcommand_format_server(fusion_config: &FusionConfig) {
    let file_content = FusionFileContent::load_stdin().unwrap_or_else(|err| bail!("{}", err));
    let file = file_content
        .parse(fusion_config)
        .unwrap_or_else(|err| bail!("{}", err));
    let formatted = format::format(fusion_config, &file.ast);
    print!("{}", formatted)
}
